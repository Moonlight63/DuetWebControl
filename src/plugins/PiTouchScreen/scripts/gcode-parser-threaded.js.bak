/**
 * @fileoverview GCODE parser
 * Based on https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/GCodeLoader.js
 * @author tentone
 * @author joewalnes
 * @author wakeful-cloud
 */

import {
	// LineBasicMaterial,
	// BufferGeometry,
	// Float32BufferAttribute,
	// Line,
	// // CatmullRomCurve3,
	// TubeBufferGeometry,
	// Vector3,
	// Mesh,
	// MeshToonMaterial,
	// BufferGeometryLoader,
	ObjectLoader,
	// LineCurve3,
	// MeshBasicMaterial
	// MeshLambertMaterial
} from 'three';

// import BufferGeometryUtils from './BufferGeometryUtils'

// import Worker from 'worker-loader!./gcode-worker.js'

// import GcodeParseWorker from 'worker-loader!./gcode-parse-worker.js';
// import PartsWorker from 'worker-loader!./create-extrusion-parts-worker.js'
// import CombineWorker from 'worker-loader!./combine-geo-worker.js';

/**
 * @class GCodeParser GCODE parser
 */
export default class GCodeParser {
	/**
	 * @param {Color} extrusionColor
	 * @param {Color} pathColor
	 */
	constructor(extrusionColor, pathColor) {
		this.extrusionColor = extrusionColor;
		this.pathColor = pathColor;
		// this.worker = new Worker(); //1.2ms

		// this.parser = new GcodeParseWorker();
		// this.workers = [];
		// this.combiner = new CombineWorker();
	}

	parseGcode(gcode) {
		return new Promise((resolve) => {
			let gcode = gcode.replace(/;.+/g, '').split('\n');

			for (let i = 0; i < gcode.length; i++) {
				//Parse tokens
				let tokens = gcode[i].split(' ');
				const command = tokens[0].toUpperCase();
				const args = {};
				tokens = tokens.splice(1);
		
				//Parse arguments
				for (let i = 0; i < tokens.length; i++) {
					//If not null, store argument
					if (tokens[i][0] != null) {
						const key = tokens[i][0].toLowerCase();
						const value = parseFloat(tokens[i].substring(1));
						args[key] = value;
					}
				}
		
				//Convert GCODE to Three.JS land
		
				//Linear move
				if (command == 'G0' || command == 'G1') {
					const line = {
						x: args.x != null ? absolute(relative, state.x, args.x) : state.x,
						y: args.y != null ? absolute(relative, state.y, args.y) : state.y,
						z: args.z != null ? absolute(relative, state.z, args.z) : state.z,
						e: args.e != null ? absolute(relative, state.e, args.e) : state.e,
						f: args.f != null ? absolute(relative, state.f, args.f) : state.f
					};
		
					//Only push valid coordinates/states
					if (!isNaN(line.x) &&
						!isNaN(line.y) &&
						!isNaN(line.z) &&
						!isNaN(line.e) &&
						!isNaN(line.f)
					) {
						//Extruding
						if (delta(relative, state.e, line.e) > 0) {
							extrusionVertices.push(line.x, line.y, line.z);							
							extrusionPaths.push([lastVec, [line.x, line.y, line.z]]);
						}
						//Path
						else {
							pathVertices.push([line.x, line.y, line.z]);
						}
		
						lastVec = [line.x, line.y, line.z];
					}
		
					//Update position
					state = line;
				}
				//Absolute positioning
				else if (command == 'G90') {
					relative = false;
				}
				//Relative positioning
				else if (command == 'G91') {
					relative = true;
				}
				//Set position
				else if (command == 'G92') {
					state = args;
				}
			}
		});
	}

	createWorkers(workerCount) {
		let workers = new Array(workerCount);
		for (let i = 0; i < workerCount; i++) {
			workers[i] = new PartsWorker();
		}
		return workers;
	}
	doWork(worker, data) {
		return new Promise(function(resolve) {
			worker.onmessage = (result) => {worker.terminate(); resolve(result);};
			worker.postMessage(data);
		});
	}
	doDistributedWork(workers, data) {
		// if (workers.length != data.length)
		// 	console.error("NOT ENOUGH WORKERS FOR DATA!!!");

		return Promise.all(workers.map(function(worker, index) {
			return this.doWork(worker, {paths:data[index], color:this.extrusionColor });
		}, this));
	}

	/**
	 * Parse GCODE
	 * @param {String} gcode The raw GCODE
	 * @returns {Promise<Object>}
	 */
	async parse(gcode) {

		//Parse asynchronously and without blocking Three.JS
		return new Promise(resolve => {

			console.time("Full Time: ");
			this.doWork(this.parser, gcode)
			.then( ({data}) => {
				this.parser.terminate();
				this.parser = null;
				this.workers = this.createWorkers(data.length);
				// this.workers = this.createWorkers(50);
				// console.log(data);
				
				return this.doDistributedWork(this.workers, data);
			})
			.then( ( all ) => {

				this.workers.forEach( worker => {
					worker.terminate();
				});
				this.workers = null;

				let geos = []
				all.forEach( ({ data }) => {
					geos.push(data.geo);
				})

				// console.log(geos);
				return this.doWork(this.combiner, {geoJson: geos, extrusionColor: this.extrusionColor});
			})
			.then( ({ data }) => {
				this.combiner.terminate();
				this.combiner = null;
				console.timeEnd("Full Time: ");
				return resolve({
					path: [],
					extrusion: new ObjectLoader().parse(data.mesh)
				});
			})


			

			// this.worker.onmessage = ({ data }) => {
			// 	console.log("Worker Done!");
			// 	console.timeEnd("Transfer: ");
			// 	// const vertexBuffer = new Float32BufferAttribute(data.myVertexData, 3); 
			// 	// let geometry = new BufferGeometry(); 
			// 	// geometry.setAttribute('position', vertexBuffer);

			// 	// let geo2 = new BufferGeometryLoader().parse(data.geo);
				
			// 	// let tubeMesh = new Mesh(geo2, this.tubeMaterial);

			// 	console.time("Mesh Load: ");
			// 	let newMesh = new ObjectLoader().parse(data.mesh);
			// 	console.timeEnd("Mesh Load: ");
			// 	console.timeEnd("Full Run: ");

			// 	return resolve({
			// 		// path: pathObject,
			// 		extrusion: newMesh
			// 	});
			// };
			// console.time("Full Run: ");	// 23211ms!
			// this.worker.postMessage({gcode: gcode, extrusionColor: this.extrusionColor});


			// let parts = [];

			// this.parser.postMessage(gcode);
			// this.parser.onmessage = ({ data }) => {
			// 	console.log(data);
			// 	//this.parser.terminate();
			// 	//this.parser = null;
			// 	let pathCount = data.extrusionPaths.length;
			// 	data.extrusionPaths.forEach(path => {
			// 		// console.log("Creating Worker!");
			// 		let partsWorker = new PartsWorker();
			// 		partsWorker.postMessage({path: path});
			// 		partsWorker.onmessage = ({ part }) => {
			// 			parts.push(part.gcode);
			// 			//partsWorker.terminate();
			// 			//partsWorker = null;

			// 			if (parts.length === pathCount) {
			// 				console.log("Parts Done");
			// 				console.log(parts);
							
			// 			}
			// 		};
			// 	});

			// 	return resolve({
			// 		path: [],
			// 		extrusion: []
			// 	});
			// };


			// return resolve({
			// 	path: pathObject,
			// 	extrusion: tubeMesh
			// });
		});
	}
}

// //Calculate the delta between 2 vertices
// function delta(relative, vertex1, vertex2) {
// 	return relative ? vertex2 : vertex2 - vertex1;
// }

// //Calculate the absolute value between 2 vertices
// function absolute(relative, vertex1, vertex2) {
// 	return relative ? vertex1 + vertex2 : vertex2;
// }