/**
 * @fileoverview GCODE parser
 * Based on https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/GCodeLoader.js
 * @author tentone
 * @author joewalnes
 * @author wakeful-cloud
 */

import {
	// LineBasicMaterial,
	// BufferGeometry,
	// Float32BufferAttribute,
	// Line,
	// // CatmullRomCurve3,
	// TubeBufferGeometry,
	// Vector3,
	// Mesh,
	// MeshToonMaterial,
	// BufferGeometryLoader,
	ObjectLoader,
	// LineCurve3,
	// MeshBasicMaterial
	// MeshLambertMaterial
} from 'three';

// import BufferGeometryUtils from './BufferGeometryUtils'

// import Worker from 'worker-loader!./gcode-worker.js'

import GcodeParseWorker from 'worker-loader!./gcode-parse-worker.js';
import PartsWorker from 'worker-loader!./create-extrusion-parts-worker.js'
import CombineWorker from 'worker-loader!./combine-geo-worker.js';

/**
 * @class GCodeParser GCODE parser
 */
export default class GCodeParser {
	/**
	 * @param {Color} extrusionColor
	 * @param {Color} pathColor
	 */
	constructor(extrusionColor, pathColor) {
		this.extrusionColor = extrusionColor;
		this.pathColor = pathColor;
		// this.worker = new Worker(); //1.2ms

		this.parser = new GcodeParseWorker();
		this.workers = [];
		this.combiner = new CombineWorker();
	}

	createWorkers(workerCount) {
		let workers = new Array(workerCount);
		for (let i = 0; i < workerCount; i++) {
			workers[i] = new PartsWorker();
		}
		return workers;
	}
	doWork(worker, data) {
		return new Promise(function(resolve) {
			worker.onmessage = (result) => {worker.terminate(); resolve(result);};
			worker.postMessage(data);
		});
	}
	doDistributedWork(workers, data) {
		// if (workers.length != data.length)
		// 	console.error("NOT ENOUGH WORKERS FOR DATA!!!");

		return Promise.all(workers.map(function(worker, index) {
			return this.doWork(worker, {paths:data[index], color:this.extrusionColor });
		}, this));
	}

	/**
	 * Parse GCODE
	 * @param {String} gcode The raw GCODE
	 * @returns {Promise<Object>}
	 */
	async parse(gcode) {

		//Parse asynchronously and without blocking Three.JS
		return new Promise(resolve => {

			console.time("Full Time: ");
			this.doWork(this.parser, gcode)
			.then( ({data}) => {
				this.parser.terminate();
				this.parser = null;
				this.workers = this.createWorkers(data.length);
				// this.workers = this.createWorkers(50);
				// console.log(data);
				
				return this.doDistributedWork(this.workers, data);
			})
			.then( ( all ) => {

				this.workers.forEach( worker => {
					worker.terminate();
				});
				this.workers = null;

				let geos = []
				all.forEach( ({ data }) => {
					geos.push(data.geo);
				})

				// console.log(geos);
				return this.doWork(this.combiner, {geoJson: geos, extrusionColor: this.extrusionColor});
			})
			.then( ({ data }) => {
				this.combiner.terminate();
				this.combiner = null;
				console.timeEnd("Full Time: ");
				return resolve({
					path: [],
					extrusion: new ObjectLoader().parse(data.mesh)
				});
			})


			

			// this.worker.onmessage = ({ data }) => {
			// 	console.log("Worker Done!");
			// 	console.timeEnd("Transfer: ");
			// 	// const vertexBuffer = new Float32BufferAttribute(data.myVertexData, 3); 
			// 	// let geometry = new BufferGeometry(); 
			// 	// geometry.setAttribute('position', vertexBuffer);

			// 	// let geo2 = new BufferGeometryLoader().parse(data.geo);
				
			// 	// let tubeMesh = new Mesh(geo2, this.tubeMaterial);

			// 	console.time("Mesh Load: ");
			// 	let newMesh = new ObjectLoader().parse(data.mesh);
			// 	console.timeEnd("Mesh Load: ");
			// 	console.timeEnd("Full Run: ");

			// 	return resolve({
			// 		// path: pathObject,
			// 		extrusion: newMesh
			// 	});
			// };
			// console.time("Full Run: ");	// 23211ms!
			// this.worker.postMessage({gcode: gcode, extrusionColor: this.extrusionColor});


			// let parts = [];

			// this.parser.postMessage(gcode);
			// this.parser.onmessage = ({ data }) => {
			// 	console.log(data);
			// 	//this.parser.terminate();
			// 	//this.parser = null;
			// 	let pathCount = data.extrusionPaths.length;
			// 	data.extrusionPaths.forEach(path => {
			// 		// console.log("Creating Worker!");
			// 		let partsWorker = new PartsWorker();
			// 		partsWorker.postMessage({path: path});
			// 		partsWorker.onmessage = ({ part }) => {
			// 			parts.push(part.gcode);
			// 			//partsWorker.terminate();
			// 			//partsWorker = null;

			// 			if (parts.length === pathCount) {
			// 				console.log("Parts Done");
			// 				console.log(parts);
							
			// 			}
			// 		};
			// 	});

			// 	return resolve({
			// 		path: [],
			// 		extrusion: []
			// 	});
			// };


			// return resolve({
			// 	path: pathObject,
			// 	extrusion: tubeMesh
			// });
		});
	}
}

// //Calculate the delta between 2 vertices
// function delta(relative, vertex1, vertex2) {
// 	return relative ? vertex2 : vertex2 - vertex1;
// }

// //Calculate the absolute value between 2 vertices
// function absolute(relative, vertex1, vertex2) {
// 	return relative ? vertex1 + vertex2 : vertex2;
// }